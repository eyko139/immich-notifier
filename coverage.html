
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>util: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/eyko139/immich-notifier/cmd/util/util.go (33.3%)</option>
				
				<option value="file1">github.com/eyko139/immich-notifier/cmd/web/app.go (0.0%)</option>
				
				<option value="file2">github.com/eyko139/immich-notifier/cmd/web/handlers.go (22.1%)</option>
				
				<option value="file3">github.com/eyko139/immich-notifier/cmd/web/helper.go (9.1%)</option>
				
				<option value="file4">github.com/eyko139/immich-notifier/cmd/web/main.go (0.0%)</option>
				
				<option value="file5">github.com/eyko139/immich-notifier/cmd/web/middleware.go (72.2%)</option>
				
				<option value="file6">github.com/eyko139/immich-notifier/cmd/web/routes.go (94.7%)</option>
				
				<option value="file7">github.com/eyko139/immich-notifier/cmd/web/web_testutils.go (75.9%)</option>
				
				<option value="file8">github.com/eyko139/immich-notifier/internal/assert/assert.go (66.7%)</option>
				
				<option value="file9">github.com/eyko139/immich-notifier/internal/auth/auth.go (0.0%)</option>
				
				<option value="file10">github.com/eyko139/immich-notifier/internal/env/env.go (97.5%)</option>
				
				<option value="file11">github.com/eyko139/immich-notifier/internal/errors/session_errors.go (0.0%)</option>
				
				<option value="file12">github.com/eyko139/immich-notifier/internal/errors/templating_error.go (0.0%)</option>
				
				<option value="file13">github.com/eyko139/immich-notifier/internal/models/immich.go (0.0%)</option>
				
				<option value="file14">github.com/eyko139/immich-notifier/internal/models/mocks/immich.go (75.0%)</option>
				
				<option value="file15">github.com/eyko139/immich-notifier/internal/models/mocks/user.go (72.7%)</option>
				
				<option value="file16">github.com/eyko139/immich-notifier/internal/models/templates.go (80.0%)</option>
				
				<option value="file17">github.com/eyko139/immich-notifier/internal/models/user.go (0.0%)</option>
				
				<option value="file18">github.com/eyko139/immich-notifier/internal/notifier/notificationService.go (83.3%)</option>
				
				<option value="file19">github.com/eyko139/immich-notifier/internal/notifier/notifier.go (28.1%)</option>
				
				<option value="file20">github.com/eyko139/immich-notifier/internal/test_utils/test_utils.go (80.0%)</option>
				
				<option value="file21">github.com/eyko139/immich-notifier/internal/util/util.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package util

import (
        "bytes"
        "errors"
        "fmt"
        "html/template"
        "log"
        "net/http"
        "os"
        "path/filepath"
        "runtime/debug"

        customErr "github.com/eyko139/immich-notifier/internal/errors"
        "github.com/eyko139/immich-notifier/internal/models"
)

type Helper struct {
        TemplateCache map[string]*template.Template
        InfoLog       *log.Logger
        ErrorLog      *log.Logger
}

func New(templateCache map[string]*template.Template, errlog, infolog *log.Logger) *Helper <span class="cov8" title="1">{
        return &amp;Helper{
                TemplateCache: templateCache,
        InfoLog: infolog,
        ErrorLog: errlog,
        }
}</span>

func (h *Helper) Render(w http.ResponseWriter, template string, data any) <span class="cov8" title="1">{
        if ts, ok := h.TemplateCache[template]; !ok </span><span class="cov0" title="0">{
                h.ServerError(w, customErr.NewTemplateError(errors.New("Could not fetch template from cache")))
        }</span> else<span class="cov8" title="1"> {

                // writing template to a buffer first catches runtime errors
                buf := new(bytes.Buffer)

                err := ts.ExecuteTemplate(buf, "base", data)
                if err != nil </span><span class="cov0" title="0">{
                    h.ServerError(w, customErr.NewTemplateError(err))
                }</span>
                <span class="cov8" title="1">buf.WriteTo(w)</span>
        }
}

func (h *Helper) ReturnHtml(w http.ResponseWriter, templateName string, data any) <span class="cov0" title="0">{
        cwd, err := os.Getwd()

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">staticPath := filepath.Join(cwd, "ui/html/singles")

        ts, err := template.ParseFiles(staticPath + "/" + templateName)

        if err != nil </span><span class="cov0" title="0">{
        h.ServerError(w, err)
        }</span>

        <span class="cov0" title="0">ts.ExecuteTemplate(w, "base", data)</span>
}

func (h *Helper) NewTemplateData(albums []models.Album, email, name string, telegramAvailable bool, userId string) *models.TemplateData <span class="cov8" title="1">{
        return &amp;models.TemplateData{
                Albums: albums,
                User:   models.UserContext{Email: email, Name: name, TelegramAvailable: telegramAvailable, Authenticated: true, ID: userId},
        }
}</span>

func (h *Helper) ServerError(w http.ResponseWriter, err error) <span class="cov0" title="0">{
        trace := fmt.Sprintf("%s\n%s", err.Error(), debug.Stack())
        // set frame depth to 2, we don't want to see this line first on the stack trace
        // when error occurs
        h.ErrorLog.Output(2, trace)
        h.ErrorLog.Print(trace)
        http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "github.com/eyko139/scs/mongodbstore"
        "github.com/eyko139/scs/v2"
        "github.com/coreos/go-oidc"
        "github.com/eyko139/immich-notifier/cmd/util"
        "github.com/eyko139/immich-notifier/internal/auth"
        "github.com/eyko139/immich-notifier/internal/env"
        "github.com/eyko139/immich-notifier/internal/models"
        "github.com/eyko139/immich-notifier/internal/notifier"
        "go.mongodb.org/mongo-driver/v2/mongo"
        "go.mongodb.org/mongo-driver/v2/mongo/options"
        "golang.org/x/oauth2"
        "log"
        "os"
        "time"
)

type App struct {
        ErrorLog       *log.Logger
        InfoLog        *log.Logger
        Helper         *util.Helper
        Immich         models.ImmichModelInterface
        Users          models.UserModelInterface
        Notifier       *notifier.Notifier
        OauthConfig    *oauth2.Config
        OauthProvider  *oidc.Provider
        SessionManager *scs.SessionManager
        Env            *env.Env
}

var sessionManager *scs.SessionManager

func NewApp(env *env.Env) *App <span class="cov0" title="0">{
        errLog := log.New(os.Stderr, "ERROR\t", log.Ldate|log.Ltime|log.Lshortfile)
        infoLog := log.New(os.Stdout, "INFO\t", log.Ldate|log.Ltime)


    infoLog.Printf("Connecting to DB %s", env.DbConnectionString)
    options := options.Client().SetTimeout(5 * time.Second).ApplyURI(env.DbConnectionString)

        client, err := mongo.Connect(options)
        if err != nil </span><span class="cov0" title="0">{
                errLog.Printf("Failed to connect to DB %s", err)
        }</span>

    <span class="cov0" title="0">pingCtx := context.Background()
    ctx, cancel := context.WithTimeout(pingCtx, 5 * time.Second)
    defer cancel()
        pingErr := client.Ping(ctx, nil)

        if pingErr != nil </span><span class="cov0" title="0">{
                errLog.Printf("Database Ping failed, err: %s", pingErr)
        }</span>

    <span class="cov0" title="0">db:= client.Database("Notify")
    
        sessionManager = scs.New()
    sessionManager.Store = mongodbstore.New(db)
        sessionManager.Lifetime = 24 * time.Hour
        sessionManager.Cookie.Secure = false // Enable secure cookie in production




        tc, err := models.NewTemplateCache()

        if err != nil </span><span class="cov0" title="0">{
                errLog.Panicf("Failed to create templateCache, err: %s", err)
        }</span>

        <span class="cov0" title="0">oAuthConfig, provider := auth.NewOauthConfig(env.OidcIssuerUrl, env.OidcClientId, env.OidcClientSecret, env.OidcRedirectUrl)

        helper := util.New(tc, errLog, infoLog)

        return &amp;App{
                ErrorLog:       errLog,
                InfoLog:        infoLog,
                Helper:         helper,
                Users:          models.NewUserModel(db),
                Immich:         models.NewImmichModel(db, env),
                Notifier:       notifier.New(client, env, models.NewImmichModel(db, env), errLog, infoLog),
                OauthConfig:    oAuthConfig,
                OauthProvider:  provider,
                Env:            env,
                SessionManager: sessionManager,
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "crypto/rand"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/coreos/go-oidc"
        "github.com/eyko139/immich-notifier/internal/models"
        "github.com/julienschmidt/httprouter"
        "golang.org/x/oauth2"
)

var stateStore = make(map[string]bool)

func (a *App) home() http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                mail := a.SessionManager.GetString(r.Context(), "user_email")
                name := a.SessionManager.GetString(r.Context(), "user_name")

                albums, err := a.Immich.FetchAlbums(mail)

        if err != nil </span><span class="cov0" title="0">{
            a.Helper.ServerError(w, err)
        }</span>

                <span class="cov8" title="1">user, err := a.Users.FindOrInsertUser(name, mail)

                if err != nil </span><span class="cov0" title="0">{
            a.Helper.ServerError(w, err)
                }</span>

                <span class="cov8" title="1">a.SessionManager.Put(r.Context(), "user_chatId", user.ChatId)

                for _, sub := range user.Subscriptions </span><span class="cov8" title="1">{
                        for idx, album := range albums </span><span class="cov8" title="1">{
                                if sub.Id == album.Id </span><span class="cov8" title="1">{
                                        albums[idx].IsSubscribed = true
                                }</span>
                        }
                }
                <span class="cov8" title="1">templateData := a.Helper.NewTemplateData(albums, mail, name, user.ChatId != 0, user.ID.Hex())
        a.Helper.Render(w, "home.html", templateData)</span>
        }
}

func (a *App) botHook() http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                var botResponse models.BotResponse

                if err := json.NewDecoder(r.Body).Decode(&amp;botResponse); err != nil </span><span class="cov0" title="0">{
                        a.ErrorLog.Printf("Error parsing bot response: %s", err)
                }</span>

                <span class="cov0" title="0">if strings.HasPrefix(botResponse.Message.Text, "/start") </span><span class="cov0" title="0">{
                        parts := strings.SplitN(botResponse.Message.Text, " ", 2)
                        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                                a.InfoLog.Println("Bothook query: " + parts[1])
                                userId := parts[1]
                                if err := a.Users.ActivateSubscriptions(userId, botResponse.Message.From.Id); err != nil </span><span class="cov0" title="0">{
                                        a.ErrorLog.Println("Failed to activate subscription, error: " + err.Error())
                                        return
                                }</span>
                <span class="cov0" title="0">_, err := a.Notifier.SendTelegramMessage(botResponse.Message.From.Id, fmt.Sprintf("Bot activated, return to website: %s", a.Env.WebsiteURL))
                if err != nil </span><span class="cov0" title="0">{
                    a.ErrorLog.Println("Failed to send message to telegram: " + err.Error())
                }</span>
                        } else<span class="cov0" title="0"> {
                                a.InfoLog.Println("Bothook called with no parameters")
                        }</span>
                }
        }
}

func (a *App) login() http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                var authCodeURL string
                state, _ := generateState()
                stateStore[state] = true
                if a.Env.AppEnv == "development" </span><span class="cov0" title="0">{
                        authCodeURL = "/"
                }</span> else<span class="cov0" title="0"> {
                        authCodeURL = a.OauthConfig.AuthCodeURL(state, oauth2.AccessTypeOffline)
                }</span>

                <span class="cov0" title="0">http.Redirect(w, r, authCodeURL, http.StatusFound)</span>
        }
}

func (a *App) handleCallback() http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ctx := context.Background()

                // Verify state parameter
                state := r.URL.Query().Get("state")
                if !stateStore[state] </span><span class="cov0" title="0">{
                        http.Error(w, "Invalid state parameter", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov0" title="0">delete(stateStore, state)

                // Exchange the authorization code for a token
                token, err := a.OauthConfig.Exchange(ctx, r.URL.Query().Get("code"))
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to exchange token: "+err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                // Extract ID Token from OAuth2 token
                <span class="cov0" title="0">rawIDToken, ok := token.Extra("id_token").(string)
                if !ok </span><span class="cov0" title="0">{
                        http.Error(w, "No id_token in token response", http.StatusInternalServerError)
                        return
                }</span>

                // Parse and verify ID Token
                <span class="cov0" title="0">verifier := a.OauthProvider.Verifier(&amp;oidc.Config{ClientID: a.Env.OidcClientId})
                idToken, err := verifier.Verify(ctx, rawIDToken)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to verify ID Token: "+err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                // Get user information from ID token
                <span class="cov0" title="0">var claims struct {
                        Email string `json:"email"`
                        Name  string `json:"name"`
                }
                if err := idToken.Claims(&amp;claims); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to parse ID Token claims: "+err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov0" title="0">if claims.Email == "" || claims.Name == "" </span><span class="cov0" title="0">{
                        http.Error(w, "Missing email or username in token: "+err.Error(), http.StatusInternalServerError)
                }</span>
                <span class="cov0" title="0">sessionManager.Put(r.Context(), "authenticated", true)
                sessionManager.Put(r.Context(), "user_email", claims.Email)
                sessionManager.Put(r.Context(), "user_name", claims.Name)

                user, _ := a.Users.FindOrInsertUser(claims.Name, claims.Email)

                a.InfoLog.Printf("created user: %+v", user)

                http.Redirect(w, r, "/", http.StatusSeeOther)</span>
        }
}

func generateState() (string, error) <span class="cov0" title="0">{
        b := make([]byte, 16)
        _, err := rand.Read(b)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return base64.URLEncoding.EncodeToString(b), nil</span>
}

func (a *App) subAlbumPost() http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                params := httprouter.ParamsFromContext(r.Context())
                id := params.ByName("albumId")

                user, err := a.GetCurrentSessionUser(r)

        if err != nil </span><span class="cov0" title="0">{
            a.ErrorLog.Printf("Error getting current session user: %s", err)
            return 
        }</span>

        <span class="cov0" title="0">a.InfoLog.Printf("User: %s subscribing to album: %s", user.Email, id)

                var subscription models.AlbumSubscription

                album, err := a.Immich.FetchAlbumsDetails(id)

                if err != nil </span><span class="cov0" title="0">{
                        a.ErrorLog.Printf("Error fetching api details: %s", err)
            return
                }</span>

                <span class="cov0" title="0">subscription.Id = album.Id
                subscription.AlbumName = album.AlbumName
                subscription.LastNotified = time.Now()
                user.Subscriptions = append(user.Subscriptions, subscription)

                if err := a.Users.UpdateSubscription(user.Email, subscription); err != nil </span><span class="cov0" title="0">{
                        a.ErrorLog.Printf("Failed to update album subscription: %s", err.Error())
                }</span>
        }
}

func (a *App) logout() http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                sessionManager.Destroy(r.Context())
                w.Header().Set("HX-Location", "/logout-success")
        }</span>
}

func (a *App) logoutSuccess() http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                a.Helper.Render(w, "logout.html", nil)
        }</span>
}

func (a *App) health() http.HandlerFunc <span class="cov8" title="1">{
    return func (w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("OK"))
    }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "github.com/eyko139/immich-notifier/internal/models"
        customErrors "github.com/eyko139/immich-notifier/internal/errors"
        "net/http"
)

func (a *App) isAuthenticated(r *http.Request) bool <span class="cov8" title="1">{
        return a.SessionManager.GetBool(r.Context(), "authenticated")
}</span>

func (a *App) GetCurrentSessionUser(r *http.Request) (*models.User, error) <span class="cov0" title="0">{
        var user models.User
        email := a.SessionManager.GetString(r.Context(), "user_email")
        name := a.SessionManager.GetString(r.Context(), "user_name")
        chatId := a.SessionManager.GetInt(r.Context(), "user_chatId")

    if email == "" || name == "" </span><span class="cov0" title="0">{
        return nil, &amp;customErrors.NoUserInSessionError{Session: a.SessionManager.Token(r.Context()), Message: "session"}
    }</span>

        <span class="cov0" title="0">user.Email = email
        user.Name = name
    user.ChatId = chatId
        return &amp;user, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "github.com/eyko139/immich-notifier/internal/env"
        "net/http"
        "time"
)

func main() <span class="cov0" title="0">{

        env := env.New()

        app := NewApp(env)

    app.InfoLog.Println("Initialized app, starting notification loop")

        go app.Notifier.StartLoop()

        srv := http.Server{
                ErrorLog:     app.ErrorLog,
                Addr:         ":" + env.AppPort,
                Handler:      app.Routes(),
                IdleTimeout:  time.Minute,
                ReadTimeout:  5 * time.Second,
                WriteTimeout: 10 * time.Second,
        }

        err := srv.ListenAndServe()
        app.ErrorLog.Fatal(err)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import "net/http"

func (a *App) LogRequests(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                a.InfoLog.Printf("%s - %s %s %s", r.RemoteAddr, r.Proto, r.Method,
                        r.URL.RequestURI())
                next.ServeHTTP(w, r)
        }</span>)
}

func secureHeaders(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                //w.Header().Set("Access-Control-Allow-Origin", "http://localhost:5173")
                w.Header().Set("X-Content-Type-Options", "nosniff")
                w.Header().Set("X-Frame-Options", "deny")
                w.Header().Set("X-XSS-Protection", "0")
                next.ServeHTTP(w, r)
        }</span>)
}

func (a *App) requireAuthentication(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
        if a.Env.AppEnv == "development" </span><span class="cov0" title="0">{
            a.SessionManager.Put(r.Context(), "authenticated", true)
            a.SessionManager.Put(r.Context(), "user_email", "mud2@gmx.de")
            a.SessionManager.Put(r.Context(), "user_name", "Administrator")
        }</span>
                <span class="cov8" title="1">if !a.isAuthenticated(r) </span><span class="cov0" title="0">{
                        http.Redirect(w, r, "/login", http.StatusSeeOther)
                        return
                }</span>
                <span class="cov8" title="1">w.Header().Add("Cache-Control", "no-store")
                next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "github.com/julienschmidt/httprouter"
        "github.com/justinas/alice"
        "net/http"
        "os"
        "path/filepath"
)

func (a *App) Routes() http.Handler <span class="cov8" title="1">{

        router := httprouter.New()

        cwd, err := os.Getwd() // Get the current working directory
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">staticPath := filepath.Join(cwd, "ui/static")

        fileServer := http.FileServer(http.Dir(staticPath))

        dynamic := alice.New(a.SessionManager.LoadAndSave)
        router.Handler(http.MethodGet, "/static/*filepath", http.StripPrefix("/static", fileServer))
        router.Handler(http.MethodPost, "/bothook", dynamic.ThenFunc(a.botHook()))
        router.Handler(http.MethodGet, "/login", dynamic.ThenFunc(a.login()))
        router.Handler(http.MethodGet, "/callback", dynamic.ThenFunc(a.handleCallback()))
    router.Handler(http.MethodGet, "/logout-success", dynamic.ThenFunc(a.logoutSuccess()))
    router.Handler(http.MethodGet, "/health", dynamic.ThenFunc(a.health()))

        protected := dynamic.Append(a.requireAuthentication)
        router.Handler(http.MethodGet, "/", protected.ThenFunc(a.home()))
    router.Handler(http.MethodPost, "/subscribe/:albumId", protected.ThenFunc(a.subAlbumPost()))
    router.Handler(http.MethodGet, "/logout", protected.ThenFunc(a.logout()))
        standard := alice.New(a.LogRequests, secureHeaders)
        return standard.Then(router)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "bytes"
        "io"
        "log"
        "net/http"
        "net/http/cookiejar"
        "net/http/httptest"
        "os"
        "testing"
        "time"

        "github.com/eyko139/immich-notifier/cmd/util"
        "github.com/eyko139/immich-notifier/internal/env"
        "github.com/eyko139/immich-notifier/internal/models"
        "github.com/eyko139/immich-notifier/internal/models/mocks"
        "github.com/eyko139/scs/v2"
)


func newTestApplication(env *env.Env) *App <span class="cov8" title="1">{

    var sessionManager *scs.SessionManager

        errLog := log.New(os.Stderr, "ERROR\t", log.Ldate|log.Ltime|log.Lshortfile)
        infoLog := log.New(os.Stdout, "INFO\t", log.Ldate|log.Ltime)

        sessionManager = scs.New()
        sessionManager.Lifetime = 24 * time.Hour

        tc, err := models.NewTemplateCache()

        if err != nil </span><span class="cov0" title="0">{
                errLog.Panicf("Failed to create templateCache, err: %s", err)
        }</span>

        <span class="cov8" title="1">helper := util.New(tc, errLog, infoLog)

    return &amp;App{
        ErrorLog: errLog, 
        InfoLog: infoLog,
        Helper: helper,
        Users: &amp;mocks.UserModel{},
        Immich: &amp;mocks.ImmichModel{},
        SessionManager: sessionManager,
        Env: env,
    }</span>
}

type testServer struct {
        *httptest.Server
}

func newTestServer(t *testing.T, handler http.Handler) *testServer <span class="cov8" title="1">{
        ts := httptest.NewServer(handler)
        jar, err := cookiejar.New(nil)

        if err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>

        <span class="cov8" title="1">ts.Client().Jar = jar
        // Disable redirect-following for the test server client by setting a custom
        // CheckRedirect function. This function will be called whenever a 3xx
        // response is received by the client, and by always returning a
        // http.ErrUseLastResponse error it forces the client to immediately return
        // the received response.
        ts.Client().CheckRedirect = func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                return http.ErrUseLastResponse
        }</span>

    <span class="cov8" title="1">return &amp;testServer{ts}</span>
}

func (ts *testServer) get(t *testing.T, url string) (int, http.Header, string) <span class="cov8" title="1">{

    rs, err := ts.Client().Get(ts.URL + url)

        if err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>

        <span class="cov8" title="1">defer rs.Body.Close()

        body, err := io.ReadAll(rs.Body)

        if err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>

        <span class="cov8" title="1">bytes.TrimSpace(body)

        return rs.StatusCode, rs.Header, string(body)</span>
}

func MockAuthenticationMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
        next.ServeHTTP(w, r)
    }</span>)
}

</pre>
		
		<pre class="file" id="file8" style="display: none">package assert

import (
    "testing"
    "strings"
)

func AssertEqual[T comparable](t *testing.T, actual, expected T) <span class="cov8" title="1">{
    t.Helper()

    if actual != expected </span><span class="cov0" title="0">{
        t.Errorf("Expected %v, got %v", expected, actual)
    }</span>
}

func StringContains(t *testing.T, actual, expected string) <span class="cov8" title="1">{
    t.Helper()

    if !strings.Contains(actual, expected) </span><span class="cov0" title="0">{
        t.Errorf("Expected %v, got %v", expected, actual)
    }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package auth

import (
        "context"
        "fmt"
        "github.com/coreos/go-oidc"
        "golang.org/x/oauth2"
)

func NewOauthConfig(issuerURL, clientID, clientSecret, redirectURL string) (*oauth2.Config, *oidc.Provider) <span class="cov0" title="0">{
        provider, err := oidc.NewProvider(context.TODO(), issuerURL)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error creating auth provider")
        }</span>
        <span class="cov0" title="0">oauth2Config := oauth2.Config{
                ClientID:     clientID,
                ClientSecret: clientSecret,
                Endpoint:     provider.Endpoint(),
                RedirectURL:  redirectURL,
                Scopes:       []string{oidc.ScopeOpenID, "profile", "groups", "openid", "email"},
        }
        return &amp;oauth2Config, provider</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package env

import "github.com/spf13/viper"

type Env struct {
        ImmichUrl          string
        ApiKey             string
        DbConnectionString string
        GotifyKey          string
        GotifyUrl          string
        OidcClientId       string
        OidcClientSecret   string
        OidcIssuerUrl      string
        OidcRedirectUrl    string
        ImmichApiKey       string
        AppPort            string
        AppEnv             string
        ImmichPollInterval int
        WebsiteURL         string
        BotURL             string
}

func New() *Env <span class="cov8" title="1">{
        env := &amp;Env{}

        viper.BindEnv("IMMICH_URL")
        viper.SetDefault("IMMICH_URL", "https://immich.itsmelon.com")
        viper.BindEnv("IMMICH_API_KEY")

        err := viper.BindEnv("DB_CONNECTION_STRING")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">viper.BindEnv("GOTIFY_KEY")

        viper.BindEnv("GOTIFY_URL")
        viper.SetDefault("GOTIFY_URL", "https://gotify.itsmelon.com/message")

        viper.BindEnv("WEBSITE_URL")
        viper.SetDefault("WEBSITE_URL", "https://bot.itsmelon.com")

        viper.BindEnv("BOT_URL")
        viper.SetDefault("BOT_URL", "https://api.telegram.org/bot6429398075:AAFjoY4mthOBReLML8qh_-Zj_K9LZdKWQKc")

        viper.BindEnv("IMMICH_POLL_INTERVAL_SECONDS")
        viper.SetDefault("IMMICH_POLL_INTERVAL_SECONDS", 60)

        viper.BindEnv("OIDC_CLIENT_ID")
        viper.BindEnv("OIDC_CLIENT_SECRET")
        viper.BindEnv("OIDC_ISSUER_URL")
        viper.BindEnv("OIDC_REDIRECT_URL")

        viper.BindEnv("API_KEY")

        viper.BindEnv("APP_PORT")
        viper.SetDefault("APP_PORT", "29442")

        viper.BindEnv("APP_ENV")
        viper.SetDefault("APP_ENV", "development")

        env.ImmichUrl = viper.GetString("IMMICH_URl")
        env.ImmichApiKey = viper.GetString("IMMICH_API_KEY")
        env.ApiKey = viper.GetString("API_KEY")
        env.DbConnectionString = viper.GetString("DB_CONNECTION_STRING")
        env.GotifyKey = viper.GetString("GOTIFY_KEY")
        env.GotifyUrl = viper.GetString("GOTIFY_URL")
        env.OidcClientId = viper.GetString("OIDC_CLIENT_ID")
        env.OidcClientSecret = viper.GetString("OIDC_CLIENT_SECRET")
        env.OidcIssuerUrl = viper.GetString("OIDC_ISSUER_URL")
        env.OidcRedirectUrl = viper.GetString("OIDC_REDIRECT_URL")
        env.AppPort = viper.GetString("APP_PORT")
        env.AppEnv = viper.GetString("APP_ENV")
        env.ImmichPollInterval = viper.GetInt("IMMICH_POLL_INTERVAL_SECONDS")
    env.BotURL = viper.GetString("BOT_URL")
        return env</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package errors

import (
    "fmt"
)

type NoUserInSessionError struct {
    Message string
    Session string
}

func (e *NoUserInSessionError) Error() string <span class="cov0" title="0">{
    return fmt.Sprintf("No found in Session: %s; err: %s", e.Session, e.Message)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package errors

import (
    "fmt"
)

type TemplateError struct {
    Err error
}

func (te *TemplateError) Error() string <span class="cov0" title="0">{
    return fmt.Sprintf("Templating error: %s", te.Err.Error())
}</span>

func NewTemplateError(err error) error <span class="cov0" title="0">{
    return &amp;TemplateError{
        Err: err,
    }
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package models

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "github.com/eyko139/immich-notifier/internal/env"
        "github.com/eyko139/immich-notifier/internal/util"
        "go.mongodb.org/mongo-driver/v2/bson"
        "go.mongodb.org/mongo-driver/v2/mongo"
        "io"
        "net/http"
        "time"
)

const (
        ImmichApiHeader = "x-api-key"
)

type Immich struct {
        url string
}

type AlbumUser struct {
        Id    string `json:"id" bson:"id"`
        Email string `json:"email" bson:"email"`
        Name  string `json:"name" bson:"name"`
}

type Album struct {
        AlbumName             string    `json:"albumName" bson:"albumName"`
        Description           string    `json:"description" bson:"description"`
        Id                    string    `json:"id" bson:"id"`
        UpdatedAt             time.Time `json:"updatedAt" bson:"updatedAt"`
        LastNotified          time.Time `json:"lastNotified" bson:"lastNotified"`
        IsSubscribed          bool      `json:"isSubscribed" bson:"isSubscribed"`
        AlbumThumbnailAssetId string    `json:"albumThumbnailAssetId" bson:"albumThumbnailAssetId"`
        B64Thumbnail          string    `json:"b64Thumbnail" bson:"b64Thumbnail"`
        AssetCount            int       `json:"assetCount" bson:"assetCount"`
        Assets                []struct {
                ID string `json:"id"`
        }
        Owner      AlbumUser `json:"owner" bson:"owner"`
        AlbumUsers []struct {
                User AlbumUser `json:"user" bson:"user"`
        } `json:"albumUsers" bson:"albumUsers"`
}

type ImmichModel struct {
        DbClient *mongo.Database
        env      *env.Env
}

type ImmichModelInterface interface {
        FetchAlbums(userEmail string) ([]Album, error)
        FetchAlbumsDetails(albumId string) (*Album, error)
        InsertOrAlbum(album Album)
    UpdateSubscription(user User)
    FetchThumbnail(uuid string) []byte 
}

func NewImmichModel(client *mongo.Database, env *env.Env) *ImmichModel <span class="cov0" title="0">{
        return &amp;ImmichModel{
                DbClient: client,
                env:      env,
        }
}</span>

func (im *ImmichModel) FetchAlbums(userEmail string) ([]Album, error) <span class="cov0" title="0">{
        var albums []Album
        req, err := http.NewRequest(http.MethodGet, im.env.ImmichUrl+"/api/albums", nil)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Header.Add(ImmichApiHeader, im.env.ImmichApiKey)

        client := http.Client{
                Timeout: 5 * time.Second,
        }

        res, err := client.Do(req)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resBytes, _ := io.ReadAll(res.Body)
        err = json.Unmarshal(resBytes, &amp;albums)
        defer res.Body.Close()

        filteredAlbums := util.Filter(userEmail, albums, IsNotEmptyAndVisible)

        for idx, album := range filteredAlbums </span><span class="cov0" title="0">{
                thumbNail := im.FetchThumbnail(album.AlbumThumbnailAssetId)
                base64String := base64.StdEncoding.EncodeToString(thumbNail)
                filteredAlbums[idx].B64Thumbnail = base64String
        }</span>

        <span class="cov0" title="0">return filteredAlbums, nil</span>
}

func (im *ImmichModel) FetchAlbumsDetails(albumId string) (*Album, error) <span class="cov0" title="0">{
        var album Album

        req, err := http.NewRequest(http.MethodGet, im.env.ImmichUrl+"/api/albums/"+albumId, nil)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Header.Add(ImmichApiHeader, im.env.ImmichApiKey)

        client := http.Client{
                Timeout: 10 * time.Second,
        }

        res, err := client.Do(req)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resBytes, _ := io.ReadAll(res.Body)
        err = json.Unmarshal(resBytes, &amp;album)
        defer res.Body.Close()
        return &amp;album, nil</span>
}

func (im *ImmichModel) InsertOrAlbum(album Album) <span class="cov0" title="0">{

        filter := bson.D{
                {
                        Key: "id", Value: album.Id,
                },
        }
        res := im.DbClient.Collection("albums").FindOneAndReplace(context.TODO(), filter, album, nil)

        if res.Err() == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">_, err := im.DbClient.Collection("albums").InsertOne(context.TODO(), album, nil)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error saving album: %s", err)
        }</span>
}

func (im *ImmichModel) UpdateSubscription(user User) <span class="cov0" title="0">{

        update := bson.D{{Key: "$set", Value: bson.D{{Key: "subscriptions", Value: user.Subscriptions}}}}

        _, err := im.DbClient.Collection("users").UpdateByID(context.TODO(), user.ID, update)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to update: %s", err)
        }</span>
}

func (im *ImmichModel) FetchThumbnail(uuid string) []byte <span class="cov0" title="0">{

        req, err := http.NewRequest(http.MethodGet, im.env.ImmichUrl+"/api/assets/"+uuid+"/thumbnail", nil)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error creating request")
        }</span>
        <span class="cov0" title="0">req.Header.Add(ImmichApiHeader, im.env.ImmichApiKey)
        req.Header.Add("Accept", "application/octet-stream")
        client := http.Client{
                Timeout: 10 * time.Second,
        }
        res, err := client.Do(req)

        bytes, _ := io.ReadAll(res.Body)
        return bytes</span>
}

func IsNotEmptyAndVisible(userEmail string, album Album) bool <span class="cov0" title="0">{
        visible := album.Owner.Email == userEmail
        for _, users := range album.AlbumUsers </span><span class="cov0" title="0">{
                if users.User.Email == userEmail </span><span class="cov0" title="0">{
                        visible = true
                }</span>
        }
        <span class="cov0" title="0">return album.AssetCount != 0 &amp;&amp; visible</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package mocks

import (
        "time"

        "github.com/eyko139/immich-notifier/internal/models"
)

type ImmichModel struct{}

func newMockAlbum() models.Album <span class="cov8" title="1">{

        var albumOwner = models.AlbumUser{
                Id:    "45",
                Email: "test1@test.de",
                Name:  "TestAlbumOwner",
        }
        var albumUser = models.AlbumUser{
                Id:    "44",
                Email: "test@test.de",
                Name:  "TestAlbumUser",
        }
        var assets = []struct {
                ID string `json:"id"`
        }{
                {ID: "15"},
        }

        var albumUsers = []struct {
                User models.AlbumUser `json:"user" bson:"user"`
        }{
                {User: albumUser},
        }

        return models.Album{
                AlbumName:             "mockAlbum",
                Description:           "very cool desc",
                Id:                    "1",
                UpdatedAt:             time.Now(),
                LastNotified:          time.Now(),
                IsSubscribed:          false,
                AlbumThumbnailAssetId: "1234",
                B64Thumbnail:          "thumbNailString",
                AssetCount:            17,
                Assets:                assets,
                Owner:                 albumOwner,
                AlbumUsers:            albumUsers,
        }
}</span>

func (im *ImmichModel) FetchAlbums(userEmail string) ([]models.Album, error) <span class="cov8" title="1">{
        return []models.Album{newMockAlbum()}, nil
}</span>
func (im *ImmichModel) FetchAlbumsDetails(albumId string) (*models.Album, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (im *ImmichModel) InsertOrAlbum(album models.Album) {<span class="cov0" title="0">
}</span>

func (im *ImmichModel) UpdateSubscription(user models.User) {<span class="cov0" title="0">
}</span>

func (im *ImmichModel) FetchThumbnail(uuid string) []byte <span class="cov0" title="0">{
        return []byte("base64mock bytes")
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package mocks

import (
        "fmt"

        "github.com/eyko139/immich-notifier/internal/models"
        "go.mongodb.org/mongo-driver/v2/bson"
)

type UserModel struct{}

var mockSubscription = models.AlbumSubscription{}

func newMockUser() *models.User <span class="cov8" title="1">{
        mockId, _ := bson.ObjectIDFromHex("123")

        var mockUser = &amp;models.User{
                Name:          "mockUser",
                Subscriptions: []models.AlbumSubscription{mockSubscription},
                Email:         "test@test.de",
                ID:            mockId,
                ApiKey:        "123",
                ChatId:        0,
        }

        return mockUser
}</span>

func (um *UserModel) UpdateSubscription(email string, subscription models.AlbumSubscription) error <span class="cov0" title="0">{
        return nil
}</span>

func (um *UserModel) FindOrInsertUser(name, email string) (models.User, error) <span class="cov8" title="1">{
        mockuser := newMockUser()
    fmt.Println(name)
    if name == "active" </span><span class="cov8" title="1">{
        mockuser.Subscriptions[0].Id = "1"
    }</span>
        <span class="cov8" title="1">return *mockuser, nil</span>
}

func (um *UserModel) RemoveSubscription(email, album string) (string, error) <span class="cov0" title="0">{
        return "", nil
}</span>

func (um *UserModel) ActivateSubscriptions(userId string, chatId int) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package models

import (
        "html/template"
        "path/filepath"
    "fmt"
    "os"
)

type TemplateData struct {
        Albums []Album
        User   UserContext

}

func NewTemplateCache() (map[string]*template.Template, error) <span class="cov8" title="1">{
    htmlPath := "ui/html"
    cwd, _ := os.Getwd()
    fmt.Println(cwd)
        cache := map[string]*template.Template{}
        pages, err := filepath.Glob(htmlPath + "/pages/*.html")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for _, page := range pages </span><span class="cov8" title="1">{
                name := filepath.Base(page)

                ts, err := template.New(name).ParseFiles(htmlPath + "/base.html")

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">ts, err = ts.ParseGlob(htmlPath + "/partials/*.html")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">ts, err = ts.ParseFiles(page)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">cache[name] = ts</span>
        }
        <span class="cov8" title="1">return cache, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package models

import (
        "context"
        "errors"
        "fmt"
        "time"

        "go.mongodb.org/mongo-driver/v2/bson"
        "go.mongodb.org/mongo-driver/v2/mongo"
)

type User struct {
        Name          string              `json:"name" bson:"name"`
        Subscriptions []AlbumSubscription `json:"subscriptions" bson:"subscriptions"`
        Email         string              `json:"email" bson:"email"`
        ID            bson.ObjectID       `json:"id" bson:"_id"`
        ApiKey        string              `json:"apiKey" bson:"apiKey"`
        ChatId        int                 `json:"chat_id" bson:"chatId"`
}

type UserContext struct {
        Email             string
        Name              string
        TelegramAvailable bool
        Authenticated     bool
        ID                string
}

type AlbumSubscription struct {
        AlbumName    string    `json:"albumName" bson:"albumName"`
        Id           string    `json:"id" bson:"id"`
        LastNotified time.Time `json:"lastNotified" bson:"lastNotified"`
}

type UserModel struct {
        DbClient *mongo.Database
}

type UserModelInterface interface {
        UpdateSubscription(email string, subscription AlbumSubscription) error
        FindOrInsertUser(name, email string) (User, error)
    RemoveSubscription(email string, albumId string) (string, error) 
    ActivateSubscriptions(userId string, chatId int) error
}

func NewUserModel(client *mongo.Database) *UserModel <span class="cov0" title="0">{
        return &amp;UserModel{
                DbClient: client,
        }
}</span>

func (um *UserModel) UpdateSubscription(email string, subscription AlbumSubscription) error <span class="cov0" title="0">{

        coll := um.DbClient.Collection("users")

        filter := bson.D{
                {
                        Key: "email", Value: email,
                },
        }

        subscriptionExists := bson.M{
                "$elemMatch": bson.M{
                        "id": subscription.Id,
                },
        }

        res := coll.FindOne(context.TODO(), bson.M{"email": email, "subscriptions": subscriptionExists})

        if errors.Is(res.Err(), mongo.ErrNoDocuments) </span><span class="cov0" title="0">{
                update := bson.M{"$push": bson.M{"subscriptions": subscription}}
                _, err := coll.UpdateOne(context.TODO(), filter, update)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                update := bson.M{"$pull": bson.M{"subscriptions": bson.M{"id": subscription.Id}}}
                _, err := coll.UpdateOne(context.TODO(), filter, update)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (um *UserModel) RemoveSubscription(email string, albumId string) (string, error) <span class="cov0" title="0">{
        filter := bson.D{
                {
                        Key: "email", Value: email,
                },
        }

        update := bson.M{"$pull": bson.M{"subscriptions": bson.M{"id": albumId}}}

        _, err := um.DbClient.Collection("users").UpdateOne(context.TODO(), filter, update)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return "ok", nil</span>
}

func (um *UserModel) FindOrInsertUser(name, email string) (User, error) <span class="cov0" title="0">{
        filter := bson.D{
                {
                        Key: "email", Value: email,
                },
        }
        res := um.DbClient.Collection("users").FindOne(context.TODO(), filter)

        if errors.Is(res.Err(), mongo.ErrNoDocuments) </span><span class="cov0" title="0">{
                user := bson.M{
                        "email": email,
                        "name":  name,
                }
                fmt.Printf("No user found for email: %s, creating...", email)
                _, err := um.DbClient.Collection("users").InsertOne(context.TODO(), user)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error creating user")
                }</span>
                <span class="cov0" title="0">return User{Name: name, Email: email}, nil</span>
        }
        <span class="cov0" title="0">var user User
        err := res.Decode(&amp;user)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("failed to decode user")
                fmt.Println(err.Error())
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}

func (um *UserModel) ActivateSubscriptions(userId string, chatId int) error <span class="cov0" title="0">{

        id, err := bson.ObjectIDFromHex(userId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">filter := bson.M{
                "_id": id,
        }

        update := bson.M{"$set": bson.M{"chatId": chatId}}

        res := um.DbClient.Collection("users").FindOneAndUpdate(context.TODO(), filter, update)
        if errors.Is(res.Err(), mongo.ErrNoDocuments) </span><span class="cov0" title="0">{
                fmt.Println("No user found")
        }</span>
        <span class="cov0" title="0">if res.Err() != nil </span><span class="cov0" title="0">{
                return res.Err()
        }</span>
        <span class="cov0" title="0">var user User
        err = res.Decode(&amp;user)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package notifier

import (
        "bytes"
        "fmt"
        "github.com/eyko139/immich-notifier/internal/models"
        "mime/multipart"
        "net/http"
)

const (
        ContentType        = "Content-Type"
        JsonContentType    = "application/json"
        GotifyAuthHeader   = "X-Gotify-Key"
)

func buildThumbnailRequest(thumbNailBytes []byte, chatId int, album models.AlbumSubscription, botURL, immichAlbumBaseURL string) *http.Request <span class="cov8" title="1">{

        caption := fmt.Sprintf("Update in album: &lt;a href='%s'&gt;%s&lt;/a&gt;", immichAlbumBaseURL+album.Id, album.AlbumName)

        picUrl := botURL + "/sendPhoto"

        var b bytes.Buffer
        w := multipart.NewWriter(&amp;b)
        formFile, err := w.CreateFormFile("photo", "preview.jpg")

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error creating form file")
        }</span>
        <span class="cov8" title="1">_, err = formFile.Write(thumbNailBytes)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error writing thumbnail bytes")
        }</span>

        <span class="cov8" title="1">chatIdFormField, _ := w.CreateFormField("chat_id")
        _, err = chatIdFormField.Write([]byte(fmt.Sprintf("%d", chatId)))

        captionFormField, _ := w.CreateFormField("caption")
        _, err = captionFormField.Write([]byte(caption))

        parseModeFormField, _ := w.CreateFormField("parse_mode")
        _, err = parseModeFormField.Write([]byte("HTML"))

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error writing chatId")
        }</span>

        <span class="cov8" title="1">err = w.Close()

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error closing formData writer")
        }</span>

        <span class="cov8" title="1">thumbnailRequest, _ := http.NewRequest(http.MethodPost, picUrl, &amp;b)
        thumbnailRequest.Header.Set(ContentType, w.FormDataContentType())
        return thumbnailRequest</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package notifier

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "time"

        "github.com/eyko139/immich-notifier/internal/env"
        "github.com/eyko139/immich-notifier/internal/models"
        "go.mongodb.org/mongo-driver/v2/bson"
        "go.mongodb.org/mongo-driver/v2/mongo"
)

type Notifier struct {
        interval time.Duration
        client   *mongo.Client
        env      *env.Env
        immich   models.ImmichModelInterface
        errLog   *log.Logger
        infoLog  *log.Logger
}

type Notification struct {
        Message  string `json:"message"`
        Title    string `json:"title"`
        Priority int    `json:"priority"`
}

func New(client *mongo.Client, env *env.Env, immich *models.ImmichModel, errLog *log.Logger, infoLog *log.Logger) *Notifier <span class="cov0" title="0">{
        return &amp;Notifier{
                interval: time.Duration(env.ImmichPollInterval) * time.Second,
                client:   client,
                env:      env,
                immich:   immich,
                errLog:   errLog,
                infoLog:  infoLog,
        }
}</span>

func (n *Notifier) StartLoop() <span class="cov0" title="0">{

        ticker := time.NewTicker(n.interval)
        var result []models.User

        for </span><span class="cov0" title="0">{
                &lt;-ticker.C

                cursor, err := n.client.Database("Notify").Collection("users").Find(context.TODO(), bson.D{}, nil)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>

                <span class="cov0" title="0">if err := cursor.All(context.TODO(), &amp;result); err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error unpacking cursor")
                }</span>

                <span class="cov0" title="0">for _, user := range result </span><span class="cov0" title="0">{
                        for idx, subscription := range user.Subscriptions </span><span class="cov0" title="0">{

                                album, err := n.immich.FetchAlbumsDetails(subscription.Id)

                if err != nil </span><span class="cov0" title="0">{
                    n.errLog.Printf("Error fetching album: %s", err)
                }</span>

                                <span class="cov0" title="0">n.infoLog.Printf("checking dates: albumUpdate: %s, subscriptionLastNotified: %s", album.UpdatedAt, subscription.LastNotified)

                                if album.UpdatedAt.After(subscription.LastNotified) </span><span class="cov0" title="0">{
                                        user.Subscriptions[idx].LastNotified = time.Now()
                                        n.immich.UpdateSubscription(user)
                                        n.Notify(user, *album, subscription)
                                }</span>
                        }
                }
        }
}

func (n *Notifier) Notify(user models.User, album models.Album, sub models.AlbumSubscription) <span class="cov0" title="0">{
        if len(album.Assets) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">latestAssedId := album.Assets[0].ID
        thumbBytes := n.immich.FetchThumbnail(latestAssedId)
        n.Gotify(user, sub)
    res, err := n.Telegram(user, thumbBytes, sub)
    if err != nil </span><span class="cov0" title="0">{
        n.errLog.Printf("Error sending telegram message: %s", err)
    }</span>
    <span class="cov0" title="0">n.infoLog.Printf("Sent telegram message, res: %v", res)</span>
}

func (n *Notifier) SendTelegramMessage(chatId int, message string) (*http.Response, error) <span class="cov8" title="1">{

        messageRequest := buildMessageRequest(chatId, message, n.env.BotURL)

        client := http.Client{
                Timeout: 5 * time.Second,
        }

        thumbResponse, err := client.Do(messageRequest)

        if err != nil </span><span class="cov0" title="0">{
                n.errLog.Println("Error sending thumbnail" + err.Error())
        }</span>
    <span class="cov8" title="1">return thumbResponse, nil</span>
}

func (n *Notifier) Telegram(user models.User, latestAssetBytes []byte, album models.AlbumSubscription) (*http.Response, error) <span class="cov8" title="1">{

        thumbNailRequest := buildThumbnailRequest(latestAssetBytes, user.ChatId, album, n.env.BotURL, n.env.ImmichUrl+"/album/")

        client := http.Client{
                Timeout: 5 * time.Second,
        }

        thumbResponse, err := client.Do(thumbNailRequest)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
    <span class="cov8" title="1">return thumbResponse, nil</span>

}

func (n *Notifier) Gotify(user models.User, sub models.AlbumSubscription) <span class="cov0" title="0">{
        notification := Notification{
                Message:  fmt.Sprintf("Album %s has been updated, user: %s", sub.AlbumName, user.Email),
                Title:    "Immich album update",
                Priority: 1,
        }

        notificationBytes, _ := json.Marshal(notification)

        req, _ := http.NewRequest(http.MethodPost, n.env.GotifyUrl, bytes.NewBuffer(notificationBytes))
        req.Header.Set(GotifyAuthHeader, n.env.GotifyKey)
        req.Header.Set(ContentType, JsonContentType)
        client := http.Client{
                Timeout: 5 * time.Second,
        }
        res, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("failed to notify: %s", err)
        }</span>
        <span class="cov0" title="0">n.infoLog.Printf("Sent gotify notification, res: %v", res)</span>
}

func buildMessageRequest(chatId int, message, targetURL string) *http.Request <span class="cov8" title="1">{
        url := targetURL + "/sendMessage"
        a := []struct {
                ChatId int    `json:"chat_id"`
                Text   string `json:"text"`
        }{{
                ChatId: chatId,
                Text:   message,
        }}

        messageBytes, _ := json.Marshal(a[0])
        req, _ := http.NewRequest(http.MethodPost, url, bytes.NewBuffer(messageBytes))
        req.Header.Set(ContentType, JsonContentType)
        return req
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package test_utils

import (
  "os"
  "path"
  "runtime"
)

func init() <span class="cov8" title="1">{
  _, filename, _, _ := runtime.Caller(0)
  dir := path.Join(path.Dir(filename), "../..")
  err := os.Chdir(dir)
  if err != nil </span><span class="cov0" title="0">{
    panic(err)</span>
  }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package util

func Filter[T any](user string, ss []T, test func(user string, album T) bool) (ret []T) <span class="cov0" title="0">{
        for _, s := range ss </span><span class="cov0" title="0">{
                if test(user, s) </span><span class="cov0" title="0">{
                        ret = append(ret, s)
                }</span>
        }
        <span class="cov0" title="0">return</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
